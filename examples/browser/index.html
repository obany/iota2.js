<html>

<head>
    <title>iota2.js Simple Browser Example</title>
</head>

<body>
    <h1>iota2.js Simple Browser Example</h1>
    <pre id="console"></pre>
    <script src="../../dist/iota2.browser.js"></script>
    <script>
        function consoleLog(message, obj) {
            const con = document.getElementById("console");
            con.innerHTML += (message || "").replace("\t", "&nbsp;&nbsp;&nbsp;") + " " + (obj ? JSON.stringify(obj) : "") + "<br/>";
        }
        function consoleLink(lnk) {
            const con = document.getElementById("console");
            con.innerHTML += `<a href="${lnk}" target="_blank">${lnk}</a><br/>`;
        }

        async function run() {
            Iota2.setLogger(consoleLog);
            const client = new Iota2.SingleNodeClient("http://localhost:14265");

            const health = await client.health();
            consoleLog("Is the node healthy", health ? "Yes" : "No");
            consoleLog();

            const info = await client.info();
            consoleLog("Node Info");
            consoleLog("\tName:", info.name);
            consoleLog("\tVersion:", info.version);
            consoleLog("\tIs Healthy:", info.isHealthy);
            consoleLog("\tNetwork Id:", info.networkId);
            consoleLog("\tLatest Milestone Id:", info.latestMilestoneId);
            consoleLog("\tLatest Milestone Index:", info.latestMilestoneIndex);
            consoleLog("\tSolid Milestone Id:", info.solidMilestoneId);
            consoleLog("\tSolid Milestone Index:", info.solidMilestoneIndex);
            consoleLog("\tPruning Index:", info.pruningIndex);
            consoleLog("\tFeatures:", info.features);
            consoleLog();

            const tips = await client.tips();
            consoleLog("Tips");
            consoleLog("\tTip 1 Message Id:", tips.tip1MessageId);
            consoleLog("\tTip 2 Message Id:", tips.tip2MessageId);
            consoleLog();

            const submitMessage = {
                version: 1,
                parent1MessageId: tips.tip1MessageId,
                parent2MessageId: tips.tip2MessageId,
                payload: {
                    type: 2,
                    index: "Foo",
                    data: Iota2.Converter.asciiToHex("Bar")
                }
            };

            const messageIdCreated = await client.messageSubmit(submitMessage);
            consoleLog("Submit Message:");
            consoleLog("\tMessage Id", messageIdCreated);
            consoleLog();

            const message = await client.message(messageIdCreated);
            consoleLog("Get Message");
            Iota2.logMessage("", message);
            consoleLog();

            const messageMetadata = await client.messageMetadata(messageIdCreated);
            consoleLog("Message Metadata");
            consoleLog("\tMessage Id:", messageMetadata.messageId);
            consoleLog("\tParent 1 Message Id:", messageMetadata.parent1MessageId);
            consoleLog("\tParent 2 Message Id:", messageMetadata.parent2MessageId);
            consoleLog("\tIs Solid:", messageMetadata.isSolid);
            consoleLog("\tReferenced By Milestone Index:", messageMetadata.referencedByMilestoneIndex);
            consoleLog("\tLedger Inclusion State:", messageMetadata.ledgerInclusionState);
            consoleLog("\tShould Promote:", messageMetadata.shouldPromote);
            consoleLog("\tShould Reattach:", messageMetadata.shouldReattach);
            consoleLog();

            const messageRaw = await client.messageRaw(messageIdCreated);
            consoleLog("Message Raw");
            consoleLog("\tRaw:", Iota2.Converter.bytesToHex(messageRaw));
            consoleLog();

            const decoded = Iota2.deserializeMessage(new Iota2.ReadStream(messageRaw));
            consoleLog("Message Decoded");
            Iota2.logMessage("", decoded);
            consoleLog();

            const messages = await client.messagesFind("Foo");
            consoleLog("Messages");
            consoleLog("\tIndex:", messages.index);
            consoleLog("\tMax Results:", messages.maxResults);
            consoleLog("\tCount:", messages.count);
            consoleLog("\tMessage Ids:", messages.messageIds);
            consoleLog();

            const children = await client.messageChildren(tips.tip1MessageId);
            consoleLog("Children");
            consoleLog("\tMessage Id:", children.messageId);
            consoleLog("\tMax Results:", children.maxResults);
            consoleLog("\tCount:", children.count);
            consoleLog("\tChildren Message Ids:", children.childrenMessageIds);
            consoleLog();

            const milestone = await client.milestone(info.latestMilestoneIndex);
            consoleLog("Milestone");
            consoleLog("\tMilestone Index:", milestone.milestoneIndex);
            consoleLog("\tMilestone Id:", milestone.milestoneId);
            consoleLog("\tTimestamp:", milestone.timestamp);
            consoleLog();

            const output = await client.output("00000000000000000000000000000000000000000000000000000000000000000000");
            consoleLog("Output");
            consoleLog("\tMessage Id:", output.messageId);
            consoleLog("\tTransaction Id:", output.transactionId);
            consoleLog("\tOutput Index:", output.outputIndex);
            consoleLog("\tIs Spent:", output.isSpent);
            Iota2.logOutput("\t", output.output);
            consoleLog();

            const address = await client.address(output.output.address.address);
            consoleLog("Address");
            consoleLog("\tAddress:", address.address);
            consoleLog("\tMax Results:", address.maxResults);
            consoleLog("\tCount:", address.count);
            consoleLog("\tBalance:", address.balance);
            consoleLog();

            const addressOutputs = await client.addressOutputs(output.output.address.address);
            consoleLog("Address Outputs");
            consoleLog("\tAddress:", addressOutputs.address);
            consoleLog("\tMax Results:", addressOutputs.maxResults);
            consoleLog("\tCount:", addressOutputs.count);
            consoleLog("\tOutput Ids:", addressOutputs.outputIds);
            consoleLog();

            await doTransfer(client);
        }

        async function doTransfer(client) {
            // These are the default values from the Hornet alphanet configuration
            const privateKey = "256a818b2aac458941f7274985a410e57fb750f3a3a67969ece5bd9ae7eef5b2f7868ab6bb55800b77b8b74191ad8285a9bf428ace579d541fda47661803ff44";
            const publicKey = "f7868ab6bb55800b77b8b74191ad8285a9bf428ace579d541fda47661803ff44";

            consoleLog("Genesis");
            consoleLog("\tPrivate Key:", privateKey);
            consoleLog("\tPublic Key:", publicKey);

            const genesisSeedKeyPair = {
                privateKey: Iota2.Converter.hexToBytes(privateKey),
                publicKey: Iota2.Converter.hexToBytes(publicKey)
            };

            const genesisAddress = Iota2.Ed25519Address.publicKeyToAddress(genesisSeedKeyPair.publicKey);
            const genesisAddressHex = Iota2.Converter.bytesToHex(genesisAddress);
            consoleLog("\tAddress:", genesisAddressHex);

            // Create a new seed for the wallet
            const walletSeed = Iota2.Ed25519Seed.fromBytes(Iota2.Converter.hexToBytes("e57fb750f3a3a67969ece5bd9ae7eef5b2256a818b2aac458941f7274985a410"));

            // Use the new seed like a wallet with Bip32 Paths
            const walletPath = new Iota2.Bip32Path("m/0");
            const walletAddressSeed = walletSeed.generateSeedFromPath(walletPath);
            const newAddress = Iota2.Converter.bytesToHex(Iota2.Ed25519Address.publicKeyToAddress(walletAddressSeed.keyPair().publicKey));

            consoleLog("Wallet 1");
            consoleLog("\tSeed:", Iota2.Converter.bytesToHex(walletSeed.toBytes()));
            consoleLog("\tPath:", walletPath.toString());
            consoleLog(`\tAddress ${walletPath.toString()}:`, newAddress);
            consoleLog();

            // Because we are using the genesis address we must use send advanced as the input address is
            // not calculated from a Bip32 path, if you were doing a wallet to wallet transfer you can just use send
            // which calculates all the inputs/outputs for you
            const genesisAddressOutputs = await client.addressOutputs(genesisAddressHex);

            const inputsWithKeyPairs = [];

            let totalGenesis = 0;

            for (let i = 0; i < genesisAddressOutputs.outputIds.length; i++) {
                const output = await client.output(genesisAddressOutputs.outputIds[i]);
                if (!output.isSpent) {
                    inputsWithKeyPairs.push({
                        input: {
                            type: 0,
                            transactionId: output.transactionId,
                            transactionOutputIndex: output.outputIndex
                        },
                        addressKeyPair: genesisSeedKeyPair
                    });
                    totalGenesis += output.output.amount;
                }
            }

            const amountToSend = 1000;

            const outputs = [
                    // This is the transfer to the new address
                    {
                        address: newAddress,
                        amount: amountToSend
                    },
                    // Sending remainder back to genesis
                    {
                        address: genesisAddressHex,
                        amount: totalGenesis - amountToSend
                    }
                ];

            const { messageId } = await Iota2.sendAdvanced(client, inputsWithKeyPairs, outputs, "WALLET", Iota2.Converter.asciiToBytes("Not trinity"));

            consoleLog("Created Message Id", messageId);

            const newAddressBalance = await Iota2.getBalance(client, walletSeed, new Iota2.Bip32Path());
            consoleLog("Wallet 1 Address Balance", newAddressBalance);

            const unspentAddress = await Iota2.getUnspentAddress(client, walletSeed, new Iota2.Bip32Path());
            consoleLog("Wallet 1 First Unspent Address", unspentAddress);

            const allUspentAddresses = await Iota2.getUnspentAddresses(client, walletSeed, new Iota2.Bip32Path());
            consoleLog("Wallet 1 Unspent Addresses", allUspentAddresses);
        }

        run()
            .then(() => consoleLog("Done"))
            .catch((err) => consoleLog(err.toString()));

    </script>
</body>

</html>